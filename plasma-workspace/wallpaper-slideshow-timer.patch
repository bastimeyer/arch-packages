diff --git a/wallpapers/image/plugin/imagebackend.cpp b/wallpapers/image/plugin/imagebackend.cpp
index e8d51ba2bf..328486610b 100644
--- a/wallpapers/image/plugin/imagebackend.cpp
+++ b/wallpapers/image/plugin/imagebackend.cpp
@@ -14,6 +14,7 @@
 
 #include <math.h>
 
+#include <QDateTime>
 #include <QDir>
 #include <QFileInfo>
 #include <QGuiApplication>
@@ -32,6 +33,7 @@ ImageBackend::ImageBackend(QObject *parent)
     : QObject(parent)
     , m_targetSize(qGuiApp->primaryScreen()->size() * qGuiApp->primaryScreen()->devicePixelRatio())
 {
+    m_timer.setTimerType(Qt::PreciseTimer);
     connect(&m_timer, &QTimer::timeout, this, &ImageBackend::nextSlide);
 }
 
@@ -391,6 +393,32 @@ void ImageBackend::nextSlide()
     if (!m_ready || m_usedInConfig || rowCount == 0) {
         return;
     }
+
+    m_timer.stop();
+
+    // Update the wallpaper in strict time intervals defined by `m_delay`, aligned to the UNIX epoch.
+    // This synchronizes wallpaper transitions accross desktops on all screens and activities.
+    QDateTime dtnow = QDateTime::currentDateTimeUtc();
+    qint64 now = dtnow.toMSecsSinceEpoch();
+    int delay_ms = m_delay * 1000;
+    int offset_ms = now % delay_ms;
+    int duration_ms = delay_ms - offset_ms;
+
+    // `m_timer` is a `Qt::PreciseTimer`, but even this kind of timer isn't precise enough,
+    // sometimes causing an unintended double `nextSlide()` call during the wallpaper transition
+    // if the timer triggered too early in the strict `delay_ms` intervals.
+    // If `duration_ms` is less than or equal to `m_timer_duration_min`, then this means that
+    //  1. we're in an unintended double `nextSlide()` call
+    //  2. or the slideshow was started right before the end of an interval
+    // In this case, skip the wallpaper transition and wait for the next interval.
+    if (duration_ms <= m_timer_duration_min) {
+        // Adjust the timer duration: this will be corrected by the offset calculation in the following `nextSlide()`
+        m_timer.start(duration_ms + delay_ms + m_timer_duration_min);
+        return;
+    }
+
+    m_timer.start(duration_ms);
+
     int previousSlide = m_currentSlide;
     QString previousPath;
     if (previousSlide >= 0) {
@@ -411,8 +439,6 @@ void ImageBackend::nextSlide()
         m_currentSlide += 1;
         next = m_slideFilterModel->index(m_currentSlide, 0).data(ImageRoles::PackageNameRole).toString();
     }
-    m_timer.stop();
-    m_timer.start(m_delay * 1000);
     if (next.isEmpty()) {
         m_image = QUrl::fromLocalFile(previousPath);
     } else {
diff --git a/wallpapers/image/plugin/imagebackend.h b/wallpapers/image/plugin/imagebackend.h
index 57f65da94b..ad42631d2f 100644
--- a/wallpapers/image/plugin/imagebackend.h
+++ b/wallpapers/image/plugin/imagebackend.h
@@ -183,6 +183,7 @@ private:
     Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS(ImageBackend, bool, m_slideshowFoldersFirst, false, &ImageBackend::slideshowFoldersFirstChanged)
 
     QTimer m_timer;
+    const int m_timer_duration_min = 1000;
     bool m_pauseSlideshow = false;
     std::optional<decltype(std::declval<QTimer>().remainingTimeAsDuration())> m_remainingTime;
 
